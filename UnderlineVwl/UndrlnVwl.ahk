/* InKey script to provide a keyboard layout for Nigerian languages

 Version:   2.0
 Author:    Andy Kellogg

*/
;***** BUGS TO FIX *****
; * bug - if you move away from characters with arrows, context is lost and quotes behave badly
; * bug - it is possible to add tone and nasal to underdot d and b since

;***** CHANGE LOG *****
; New in 2.0
; * fixed cedilla to be NFD compliant
; * adjusted hook v and m and saltillo
; * adjusted keystroke order to match new Keyman (esp. tone)

;________________________________________________________________________________________________________________
; This section is required at the top of every InKey keyboard script:

K_MinimumInKeyLibVersion = 0.092
	  ; The version number of the InKeyLib.ahki file that the keyboard developer used while writing this script.
	  ; It can be found near the top of the InKeyLib.ahki file.
	  ; It may be lower than the InKey version number.
	  ; If a user has an older version of InKeyLib.ahki, he will need to update it in order to use this keyboard script.
	  ; This protects your script from crashing from attempting to use functionality not present in older versions of InKeyLib.ahki.

K_UseContext = 1  ; Causes uncaptured character keys to be included in the context too.

#include InKeyLib.ahki
;________________________________________________________________________________________________________________

OnLoadScript:
	KeyboardNum := 2		;1 = Open Shape, 2 = Underline, 3 = Underdot

	rota =
	( C
		c ç			;**** Lowercase
		g ɣ
		h ɦ	;is no capital form
		k ƙ
		m ɱ
		n ŋ ɲ
		s ʃ
		v ʋ
		y ƴ
		z ʒ
		C Ç			;**** Uppercase
		G Ɣ
		K Ƙ
		M Ɱ
		N Ŋ Ɲ
		S Ʃ
		V Ʋ
		Y Ƴ
		Z Ʒ
		? ꞌ				;Glottal Stop Chars
		$ ₦ £			;**** Other
	)
	RegisterRota(0, rota, 0, 0, 0x003B)						;consonant and vowel rota

	rota =
	( C
		a ə					;**** Lowercase
		e ɛ
		i ɨ ɪ
		o ɔ
		u ʊ
		b ɓ
		d ɗ
		A Ə					;**** Uppercase
		E Ɛ
		I Ɨ
		O Ɔ
		U Ʊ
		B Ɓ
		D Ɗ
	)
	RegisterRota(1, rota, 0, 0, 0x003B)						;open shape rota

	rota =
	( C
		a a̱ ə				;**** Lowercase
		e e̱
		i i̱
		o o̱
		u u̱
		b ɓ
		d ɗ
		A A̱ Ə 				;**** Uppercase
		E E̱
		I I̱
		O O̱
		U U̱
		B Ɓ
		D Ɗ
	)
	RegisterRota(2, rota, 0, 0, 0x003B)						;underline rota

	rota =
	( C
		a ạ ə				;**** Lowercase
		e ẹ
		i ị
		o ọ
		u ụ
		b ḅ
		d ḍ
		A Ạ Ə 				;**** Uppercase
		E Ẹ
		I Ị
		O Ọ
		U Ụ
		B Ḅ
		D Ḍ
	)
	RegisterRota(3, rota, 0, 0, 0x003B)				;underdot rota

	RegisterRota(4, "́ ̀ ̂ ̌ ̄", 0, 0, 0, 1)			;tone rota

	return
;________________________________________________________________________________________________________________

OnLoadKeyboard:	; InKeyLib will call this subroutine the first time InKey calls on this script for a particular keyboard.
;			(The user may configure multiple keyboards from a single keyboard script, if the keyboard script
;			supports parameters.)  The parameter string associated with the current keyboard will be contained in
;			the global named K_Params.
;			Perform any one-time keyboard-specific initialization here, such as any calls to RegisterKbdRota().
;			Also, if you need it, the numeric identifier that InKey has assigned to the current keyboard will be
;			contained in the global named K_ID.  It may be useful to use this as an array index for storing
;			keyboard-specific values.  (This may be more efficient than re-processing the K_Param string each
;			time OnKeyboardInit is called.)

	; Determine whether to use smart quotes or chevrons.  The default is smart quotes
	UseSmartQuotes := GetParam("UseSmartQuotes", 1)

;________________________________________________________________________________________________________________
; In the following mappings of keystrokes to Unicode characters to send, each keystroke code is prefixed with a
; dollar sign ($), telling InKey to act on the keystroke only if it has not been artificially generated by InKey itself.
; Some keystrokes are then prefixed with a plus sign (+), indicating the shifted form of the key.
; See the AutoHotKey documentation for a full description of the syntax for specifying hotkeys.

;** Consonant and Vowel Rota *******
$;::
	x := 1
	cc := ctx(x)
	;if the previous char(s) is/are tone or nasal, move back
	while ((cc = 0x0300) or (cc = 0x0301) or (cc = 0x0302) or (cc = 0x0304) or (cc = 0x030C) or (cc = 0x0303))
	{
		diacritics%x% := cc
		cc := ctx(++x)
	}

	Suspend, On				;This keeps user from entering tone or nasal while the letter and diacritics are re-typed
	Back(--x)
	VowelsBD := "aəeɛiɨɪoɔuʊAƏEƐIƗOƆUƱdɗDƊbɓBƁ" . Chr(0x0331) . Chr(0x0323)
	if InStr(VowelsBD, Chr(cc), true)
		DoRota(KeyboardNum)
	else
		DoRota(0)
	while (x)
	{
		SendChar(diacritics%x%)
		x--
	}
	Suspend, Off
	return

;** Tone Rotas *********************
$`::
	cc := ctx()
	;if is tone character
	if ((cc = 0x0300) or (cc = 0x0301) or (cc = 0x0302) or (cc = 0x030C))
		DoRota(4)					;make contour or extra high tone
	else if (cc = 0x0304)			;it is the last tone in the rota, delete tone marking
		DeleteChar(1, 1)
	else if not cc					;if there is no context or previous character
		return						;do nothing
	else if CanBearTone(cc)			;can bear tone
		SendChar(0x0301, 0x0301)
	return


;** Nasals *************************
$~::
$=::
	cc := ctx()
	if not cc					;if there is no context or previous character
		return						;do nothing
	else if ((cc = 0x0300) or (cc = 0x0301) or (cc = 0x0302) or (cc = 0x0304) or (cc = 0x030B) or (cc = 0x030C) or (cc = 0x030F) or (cc = 0x1DC4) or (cc = 0x1DC5) or (cc = 0x1DC6) or (cc = 0x1DC7))
	{ ;if is a tone character
		cc2 := ctx(2)
		if (cc2 = 0x0303)
			ReplaceChar(cc, 2)			;already is a tilde so remove tilde
		else if CanBearNasal(cc2)		;can bear nasalization
			InsertChar(0x0303, 0x0303)
	}
	else if (cc = 0x0303)				;is a tilde
		DeleteChar(1, 1)				;already is a tilde so remove tilde
	else if CanBearNasal(cc)			;can bear nasalization
		SendChar(0x0303, 0x0303)
	return

;** LP Quotations ******************
$<::
	;if user wants to use chevrons instead of smartquotes
	if not UseSmartQuotes
	{
		SendChar(0x003C, 0x003C)
		return
	}

	cc1 := ctx()
	cc2 := ctx(2)
	cc3 := ctx(3)
	if (cc1 = 0x2018)							;is single curly-quote
	{
		if ((cc2 = 0x0020) and (cc3 = 0x201C))
		{										;is doubly nested quote
			DoSpace()
			SendChar(0x201C, 0x003C)			;add SPACE and double curly-quote
		}
		else
			ReplaceChar(0x201C, 1, 1, 0x003C)	;make into double curly-quote
	}
	else if (cc1 = 0x201C)						;is double curly-quote
	{
		DoSpace()
		SendChar(0x2018, 0x003C)				;add SPACE and single curly-quote
	}
	else
		SendChar(0x2018, 0x003C)				;insert a single curly-quote
	return

$>::
	;if user wants to use chevrons instead of smartquotes
	if not UseSmartQuotes
	{
		SendChar(0x003E, 0x003E)
		return
	}
	cc1 := ctx()
	cc2 := ctx(2)
	cc3 := ctx(3)
	if (cc1 = 0x2019)							;is single curly-quote
	{
		if ((cc2 = 0x0020) and (cc3 = 0x201D))
		{										;is doubly nested quote
			DoSpace()
			SendChar(0x201D, 0x003E)			;add SPACE and double curly-quote
		}
		else
		ReplaceChar(0x201D, 1, 1, 0x003E)		;make into double curly-quote
	}
	else if (cc1 = 0x201D)						;is double curly-quote
	{
		if ((cc2 = 0x0020) and (cc3 = 0x2019))
		{
			DoSpace()
			SendChar(0x2019, 0x003E)			;send single curly quote
		}
		else									;do this: ’ ”
		{
			ReplaceChar(0x2019, 1, 1, 0x003E)
			DoSpace()
			SendChar(0x201D, 0x003E)
		}
	}
	else
		SendChar(0x2019, 0x003E)				;insert a single curly-quote
	return

;** CAPSLOCK (no Shift)*************
;NOTE: This is not yet fully implemented
$a::
$b::
$c::
$d::
$e::
$f::
$g::
$h::
$i::
$j::
$k::
$l::
$m::
$n::
$o::
$p::
$q::
$r::
$s::
$t::
$u::
$v::
$w::
$x::
$y::
$z::
	thekeypress := SubStr(A_ThisHotKey,0)		;remove the $ to get just the digit
	keynum := Asc(thekeypress)
	if (GetKeyState("CapsLock", "T"))			;if CapsLock is on
		keynum := keynum - 32
	SendChar(keynum)
	return

;** CAPSLOCK (with Shift)***********
$+a::
$+b::
$+c::
$+d::
$+e::
$+f::
$+g::
$+h::
$+i::
$+j::
$+k::
$+l::
$+m::
$+n::
$+o::
$+p::
$+q::
$+r::
$+s::
$+t::
$+u::
$+v::
$+w::
$+x::
$+y::
$+z::
	thekeypress := SubStr(A_ThisHotKey,0)		;remove the $ to get just the digit
	keynum := Asc(thekeypress)
	if (not GetKeyState("CapsLock", "T"))			;if CapsLock is off
		keynum := keynum - 32
	SendChar(keynum)
	return

;** Special Keys *******************
$!;::SendChar(59)     ; send ;
$!`::SendChar(96)     ; send `
$!=::SendChar(0x003D)   ; send =
$!+~::SendChar(126)   ; send ~
$!+<::SendChar(60)    ; send <
$!+>::SendChar(62)    ; send >
$!,::SendChar(60)    ; send <
$!.::SendChar(62)    ; send >

;** Defines chars that can have tone or nasalization *******
CanBearTone(CharToCheck)
{
	LtrsWithTone := "aəeɛiɨɪoɔuʊAƏEƐIƗOƆUƱmɱnŋɲMⱮNŊƝ" . Chr(0x0331) . Chr(0x0303)
	if InStr(LtrsWithTone, Chr(CharToCheck), true)
		return true
	else
	{
		if (CharToCheck = 0x0323)	;occurs under vwls & 'b' & 'd' so additional checking needed
			return true
		else
			return false
	}
}

CanBearNasal(CharToCheck)
{
	LtrsWithNasal := "aəeɛiɨɪoɔuʊAƏEƐIƗOƆUƱ" . Chr(0x0331)
	if InStr(LtrsWithNasal, Chr(CharToCheck), true)
		return true
	else
	{
		if (CharToCheck = 0x0323)	;occurs under vwls & 'b' & 'd' so additional checking needed
			return true
		else
			return false
	}
}